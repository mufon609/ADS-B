import PyIndi
import time
import os
import numpy as np
import cv2
import threading
from typing import List, Optional, Callable
from storage import append_to_json
from config_loader import CONFIG, LOG_DIR
from image_analyzer import measure_sharpness, save_png_preview
from coord_utils import get_sun_azel, slew_time_needed, get_altaz_frame, angular_sep_deg
from astropy.coordinates import SkyCoord, AltAz, EarthLocation
import astropy.units as u
from astropy.time import Time
from astropy.io import fits
from stack_orchestrator import schedule_stack_and_publish

class IndiController(PyIndi.BaseClient):
    """INDI client for mount, camera, and focuser."""
    def __init__(self):
        super().__init__()
        self.shutdown_event: Optional[threading.Event] = threading.Event()
        if CONFIG['development']['dry_run']:
            print("[DRY RUN] IndiController initialized in dry-run mode.")
            self.simulated_az_el = (180.0, 45.0)
            obs_cfg = CONFIG['observer']
            self.observer_loc = EarthLocation(
                lat=obs_cfg['latitude_deg']*u.deg,
                lon=obs_cfg['longitude_deg']*u.deg,
                height=obs_cfg['altitude_m']*u.m
            )
            return

        print("Connecting to INDI server...")
        self.setServer(CONFIG['hardware']['indi_host'], CONFIG['hardware']['indi_port'])
        if not self.connectServer():
            raise ConnectionError("Failed to connect to INDI server")
        time.sleep(3)

        self.mount = self.getDevice(CONFIG['hardware']['mount_device_name'])
        self.camera = self.getDevice(CONFIG['hardware']['camera_device_name'])
        self.focuser = self.getDevice(CONFIG['hardware']['focuser_device_name'])
        if not all([self.mount, self.camera, self.focuser]):
            raise ValueError("One or more hardware devices not found")

        self.setBLOBMode(PyIndi.B_CLIENT, self.camera.getDeviceName(), None)
        self._blob_name = self._detect_ccd_blob_name()
        self.setBLOBMode(PyIndi.B_CLIENT, self.camera.getDeviceName(), self._blob_name)
        if self.camera.getBLOB(self._blob_name) is None:
            print(f"  - Warning: BLOB vector '{self._blob_name}' not visible yet; subscribing to all BLOBs for now.")
            self.setBLOBMode(PyIndi.B_CLIENT, self.camera.getDeviceName(), None)

        print("--- Hardware Connected & Configured ---")
        for device, name in [(self.mount, "Mount"), (self.camera, "Camera"), (self.focuser, "Focuser")]:
            di = device.getText("DRIVER_INFO")
            if di and len(di) > 0 and getattr(di[0], "text", None):
                print(f"  - {name} ({device.getDeviceName()}): {di[0].text}")
            else:
                print(f"  - {name} ({device.getDeviceName()}): Driver info not available.")
        
        cam_specs = CONFIG['camera_specs']

        upload_mode = self._wait_switch(self.camera, "UPLOAD_MODE")
        if upload_mode:
            widget = upload_mode.findWidgetByName("UPLOAD_CLIENT")
            if widget:
                widget.s = PyIndi.ISS_ON
                self.sendNewSwitch(upload_mode)
                print("  - Set Camera: Upload mode to 'Client'.")

        if cam_specs.get('cooling', {}).get('enabled', False):
            cooler_switch = self._wait_switch(self.camera, "CCD_COOLER")
            if cooler_switch:
                widget = cooler_switch.findWidgetByName("COOLER_ON")
                if widget:
                    widget.s = PyIndi.ISS_ON
                    self.sendNewSwitch(cooler_switch)
            
            temp_prop = self._wait_number(self.camera, "CCD_TEMPERATURE")
            if temp_prop:
                widget = temp_prop.findWidgetByName("CCD_TEMPERATURE_VALUE")
                if widget:
                    setpoint = cam_specs['cooling']['setpoint_c']
                    widget.value = setpoint
                    self.sendNewNumber(temp_prop)
                    print(f"  - Set Camera: Cooling enabled, setpoint {setpoint}°C.")

        if 'binning' in cam_specs:
            bin_prop = self._wait_number(self.camera, "CCD_BINNING")
            if bin_prop:
                hor_widget = bin_prop.findWidgetByName("HOR_BIN")
                ver_widget = bin_prop.findWidgetByName("VER_BIN")
                if hor_widget and ver_widget:
                    hor_widget.value = cam_specs['binning']['x']
                    ver_widget.value = cam_specs['binning']['y']
                    self.sendNewNumber(bin_prop)
                    print(f"  - Set Camera: Binning to {cam_specs['binning']['x']}x{cam_specs['binning']['y']}.")

        if 'gain' in cam_specs:
            gain_prop = self._wait_number(self.camera, "CCD_GAIN")
            if gain_prop:
                widget = gain_prop.findWidgetByName("GAIN")
                if widget:
                    widget.value = cam_specs['gain']
                    self.sendNewNumber(gain_prop)
                    print(f"  - Set Camera: Gain to {cam_specs['gain']}.")

        if 'offset' in cam_specs:
            offset_prop = self._wait_number(self.camera, "CCD_OFFSET")
            if offset_prop:
                widget = offset_prop.findWidgetByName("OFFSET")
                if widget:
                    widget.value = cam_specs['offset']
                    self.sendNewNumber(offset_prop)
                    print(f"  - Set Camera: Offset to {cam_specs['offset']}.")

        print("---------------------------------------")

        obs_cfg = CONFIG['observer']
        self.observer_loc = EarthLocation(
            lat=obs_cfg['latitude_deg']*u.deg,
            lon=obs_cfg['longitude_deg']*u.deg,
            height=obs_cfg['altitude_m']*u.m
        )

    def _wait_prop(self, get_func, dev, name, timeout=3.0):
        t0 = time.time()
        while time.time() - t0 < timeout:
            prop = get_func(dev, name)
            if prop:
                return prop
            time.sleep(0.1)
        dev_name = getattr(dev, "getDeviceName", lambda: "UNKNOWN")()
        print(f"Warning: Property '{name}' not available on device '{dev_name}' after {timeout}s.")
        return None

    def _wait_number(self, dev, name, timeout=3.0):
        return self._wait_prop(PyIndi.BaseDevice.getNumber, dev, name, timeout)

    def _wait_switch(self, dev, name, timeout=3.0):
        return self._wait_prop(PyIndi.BaseDevice.getSwitch, dev, name, timeout)
        
    def _drain_blobs(self, prop_name: str, max_loops: int = 3) -> None:
        for _ in range(max_loops):
            blob_prop = self.camera.getBLOB(prop_name)
            if not (blob_prop and len(blob_prop) > 0 and blob_prop[0].bloblen > 0):
                break
            _ = blob_prop[0].getblobdata()
            time.sleep(0.05)
            
    def _detect_ccd_blob_name(self) -> str:
        for name in ("CCD1", "CCD_IMAGE", "CCD2", "CCD_PRIMARY", "CCD_MAIN", "VIDEO_STREAM"):
            try:
                if self.camera.getBLOB(name) is not None:
                    print(f"  - Detected camera BLOB property: {name}")
                    return name
            except Exception:
                pass
        print("  - Warning: Could not detect BLOB property, falling back to 'CCD1'.")
        return "CCD1"

    def get_hardware_status(self) -> dict:
        if CONFIG['development']['dry_run']:
            return {
                "mount_az_el": self.simulated_az_el,
                "camera_temp": -10.1, "camera_cooler_power": 45.5,
                "focuser_pos": 12345, "focuser_temp": 22.8,
                "mount_pier_side": "East", "camera_binning": {"x": 1, "y": 1},
                "camera_gain": 100, "camera_offset": 50
            }

        status = {}
        
        try:
            status["mount_az_el"] = self._get_current_az_el_internal()
        except Exception as e:
            status["mount_az_el"] = (0.0, 0.0)
            print(f"Warning: could not get mount az/el: {e}")
        
        pier_side_prop = self.mount.getSwitch("TELESCOPE_PIER_SIDE")
        if pier_side_prop:
            for element in pier_side_prop:
                if element.s == PyIndi.ISS_ON:
                    status["mount_pier_side"] = element.label
                    break
        
        temp_prop = self.camera.getNumber("CCD_TEMPERATURE")
        if temp_prop:
            widget = temp_prop.findWidgetByName("CCD_TEMPERATURE_VALUE")
            if widget: status["camera_temp"] = widget.value

        cooler_prop = self.camera.getNumber("CCD_COOLER_POWER")
        if cooler_prop:
            widget = cooler_prop.findWidgetByName("CCD_COOLER_VALUE")
            if widget: status["camera_cooler_power"] = widget.value

        bin_prop = self.camera.getNumber("CCD_BINNING")
        if bin_prop:
            w1 = bin_prop.findWidgetByName("HOR_BIN")
            w2 = bin_prop.findWidgetByName("VER_BIN")
            if w1 and w2: status["camera_binning"] = {"x": w1.value, "y": w2.value}
        
        gain_prop = self.camera.getNumber("CCD_GAIN")
        if gain_prop:
            widget = gain_prop.findWidgetByName("GAIN")
            if widget: status["camera_gain"] = widget.value

        offset_prop = self.camera.getNumber("CCD_OFFSET")
        if offset_prop:
            widget = offset_prop.findWidgetByName("OFFSET")
            if widget: status["camera_offset"] = widget.value

        pos_prop = self.focuser.getNumber("ABS_FOCUS_POSITION")
        if pos_prop:
            widget = pos_prop.findWidgetByName("FOCUS_ABSOLUTE_POSITION")
            if widget: status["focuser_pos"] = widget.value

        focuser_temp_prop = self.focuser.getNumber("FOCUSER_TEMPERATURE")
        if focuser_temp_prop:
            widget = focuser_temp_prop.findWidgetByName("FOCUSER_TEMPERATURE_VALUE")
            if widget: status["focuser_temp"] = widget.value
            
        return status

    def _get_current_az_el_internal(self) -> tuple:
        """Read current mount coords from INDI (horizontal preferred)."""
        horiz = self.mount.getNumber("HORIZONTAL_COORD")
        if horiz:
            az_w = horiz.findWidgetByName("AZ")
            alt_w = horiz.findWidgetByName("ALT")
            if az_w and alt_w:
                return (az_w.value, alt_w.value)
        
        eq = self.mount.getNumber("EQUATORIAL_EOD_COORD")
        if eq:
            ra_w = eq.findWidgetByName("RA")
            dec_w = eq.findWidgetByName("DEC")
            if ra_w and dec_w:
                ra, dec = ra_w.value, dec_w.value
                ra_dec = SkyCoord(ra=ra*u.hourangle, dec=dec*u.deg, frame='icrs')
                altaz = ra_dec.transform_to(AltAz(obstime=Time.now(), location=self.observer_loc))
                return (altaz.az.deg, altaz.alt.deg)
        
        raise ValueError("Mount coordinate system not found")

    def get_current_az_el(self) -> tuple[float, float]:
        """Public method to get mount az/el, honoring dry-run simulation."""
        if CONFIG['development']['dry_run']:
            return self.simulated_az_el
        return self._get_current_az_el_internal()

    def slew_to_az_el(
        self,
        az: float,
        el: float,
        progress_cb: Optional[Callable[[float, float, str], None]] = None
    ) -> bool:
        """
        Slews mount and returns True on success, False on failure/timeout.
        
        Includes predictive sun safety check.
        """
        if CONFIG['development']['dry_run']:
            frame = get_altaz_frame(self.observer_loc)
            max_slew = CONFIG['hardware']['max_slew_deg_s']
            realistic_slew_time = slew_time_needed(self.simulated_az_el, (az, el), max_slew, frame)
            
            print(f"[DRY RUN] Slewing from {self.simulated_az_el} to az/el: ({az:.2f}, {el:.2f})")
            # Simulate incremental movement so callers can live-update the dashboard
            steps = max(1, int(max(0.5, realistic_slew_time) / 0.5))
            start_az, start_el = self.simulated_az_el
            # Shortest path in azimuth (wrap-aware)
            az_delta = ((az - start_az + 180.0) % 360.0) - 180.0
            el_delta = el - start_el
            for i in range(1, steps + 1):
                if self.shutdown_event and self.shutdown_event.is_set():
                    if progress_cb:
                        try: progress_cb(*self.simulated_az_el, "abort")
                        except Exception: pass
                    print("[DRY RUN] Slew aborted by shutdown.")
                    return False
                f = i / steps
                cur_az = (start_az + f * az_delta) % 360.0
                cur_el = start_el + f * el_delta
                self.simulated_az_el = (cur_az, cur_el)
                if progress_cb:
                    try: progress_cb(cur_az, cur_el, "slewing")
                    except Exception: pass
                time.sleep(0.5)

            self.simulated_az_el = (az % 360.0, el)
            if progress_cb:
                try: progress_cb(self.simulated_az_el[0], self.simulated_az_el[1], "arrived")
                except Exception: pass
            print(f"[DRY RUN] Slew complete. Mount is now at: ({az:.2f}, {el:.2f})")
            return True

        az = az % 360.0
        el = max(-5.0, min(95.0, el))

        # Predictive Sun Safety Check
        try:
            current_az, current_el = self.get_current_az_el()
            max_slew = float(CONFIG['hardware'].get('max_slew_deg_s', 6.0))
            now_frame = get_altaz_frame(self.observer_loc)
            
            est_slew_time = slew_time_needed((current_az, current_el), (az, el), max_slew, now_frame)
            est_slew_time += 2.0

            arrival_time_unix = time.time() + est_slew_time
            arrival_time_obj = Time(arrival_time_unix, format='unix')
            sun_az_el_future = get_sun_azel(arrival_time_unix, self.observer_loc)

            future_frame = AltAz(obstime=arrival_time_obj, location=self.observer_loc)

            separation_deg_future = angular_sep_deg((az, el), sun_az_el_future, future_frame)

            min_sep = float(CONFIG['selection'].get('min_sun_separation_deg', 15.0))
            if separation_deg_future < min_sep:
                print(f"SAFETY ABORT (Predictive): Target ({az:.1f}, {el:.1f}) will be {separation_deg_future:.2f}° from Sun "
                      f"(at ~{est_slew_time:.1f}s). Min separation is {min_sep}°. Sun will be at ({sun_az_el_future[0]:.1f}, {sun_az_el_future[1]:.1f}).")
                if progress_cb:
                     try: progress_cb(current_az, current_el, "abort")
                     except Exception: pass
                return False

        except Exception as e:
            print(f"Warning: Predictive sun safety check failed: {e}. Proceeding with caution.")
            # Optionally, you could abort here if the check fails for any reason

        # Hardware Altitude Limit Check
        alt_limit_prop = self.mount.getNumber("ALTITUDE_LIMITS")
        if alt_limit_prop:
            min_el_w = alt_limit_prop.findWidgetByName("MIN")
            if min_el_w and el < min_el_w.value:
                print(f"SAFETY ABORT: Target elevation {el:.2f} is below min hardware limit of {min_el_w.value:.2f} deg.")
                if progress_cb:
                    try: progress_cb(*self.get_current_az_el(), "abort")
                    except Exception: pass
                return False
            max_el_w = alt_limit_prop.findWidgetByName("MAX")
            if max_el_w and el > max_el_w.value:
                print(f"SAFETY ABORT: Target elevation {el:.2f} exceeds max hardware limit of {max_el_w.value:.2f} deg.")
                if progress_cb:
                    try: progress_cb(*self.get_current_az_el(), "abort")
                    except Exception: pass
                return False

        coord_prop_name = ""
        horiz = self.mount.getNumber("HORIZONTAL_COORD")
        if horiz:
            coord_prop_name = "HORIZONTAL_COORD"
            horiz.findWidgetByName("ALT").value = el
            horiz.findWidgetByName("AZ").value = az
            self.sendNewNumber(horiz)
        else:
            eq = self.mount.getNumber("EQUATORIAL_EOD_COORD")
            if eq:
                coord_prop_name = "EQUATORIAL_EOD_COORD"
                altaz_frame = AltAz(obstime=Time.now(), location=self.observer_loc)
                altaz = SkyCoord(az=az*u.deg, alt=el*u.deg, frame=altaz_frame)
                ra_dec = altaz.transform_to('icrs')
                eq.findWidgetByName("RA").value = ra_dec.ra.hour
                eq.findWidgetByName("DEC").value = ra_dec.dec.deg
                self.sendNewNumber(eq)
            else:
                print("Error: Neither HORIZONTAL_COORD nor EQUATORIAL_EOD_COORD is available on the mount.")
                if progress_cb:
                    try: progress_cb(*self.get_current_az_el(), "abort")
                    except Exception: pass
                return False
        
        # Estimate timeout
        try:
            cur_az, cur_el = self.get_current_az_el()
            max_slew = float(CONFIG['hardware'].get('max_slew_deg_s', 6.0))
            dist = max(abs(((az - cur_az + 180.0) % 360.0) - 180.0), abs(el - cur_el))
            est = (dist / max_slew) if max_slew > 0 else 60.0
            slew_timeout = time.time() + max(20.0, est + 15.0)
        except Exception:
            slew_timeout = time.time() + 90.0

        # Poll while busy and report progress
        while time.time() < slew_timeout:
            coord_prop = self.mount.getNumber(coord_prop_name)
            if coord_prop and coord_prop.s == PyIndi.IPS_BUSY:
                try:
                    cur_az, cur_el = self.get_current_az_el()
                    if progress_cb:
                        try: progress_cb(cur_az, cur_el, "slewing")
                        except Exception: pass
                except Exception:
                    pass
                if self.shutdown_event and self.shutdown_event.is_set():
                    print("Slew aborted by shutdown signal.")
                    if progress_cb:
                        try: progress_cb(*self.get_current_az_el(), "abort")
                        except Exception: pass
                    return False
                time.sleep(0.5)
                continue
            break

        coord_prop = self.mount.getNumber(coord_prop_name)
        if not coord_prop or coord_prop.s == PyIndi.IPS_BUSY:
            print("Warning: Slew command timed out or property lost.")
            if progress_cb:
                try: progress_cb(*self.get_current_az_el(), "abort")
                except Exception: pass
            return False
        if coord_prop.s == PyIndi.IPS_ALERT:
            print("Warning: Slew command failed (Alert state).")
            if progress_cb:
                try: progress_cb(*self.get_current_az_el(), "abort")
                except Exception: pass
            return False

        try:
            cur_az, cur_el = self.get_current_az_el()
        except Exception:
            cur_az, cur_el = (az, el)
        if progress_cb:
            try: progress_cb(cur_az, cur_el, "arrived")
            except Exception: pass

        print(f"Slewed to az/el: ({az:.2f}, {el:.2f})")
        return True

    def autofocus(self, alt_ft: float = None) -> bool:
        if self.shutdown_event and self.shutdown_event.is_set():
            print("Autofocus aborted: shutdown requested.")
            return False
            
        if CONFIG['development']['dry_run']:
            print(f"[DRY RUN] Performing autofocus for altitude {alt_ft} ft.")
            return True

        print("Starting autofocus...")
        af_cfg = CONFIG['capture']['autofocus']
        abs_pos_prop = self.focuser.getNumber("ABS_FOCUS_POSITION")
        if not abs_pos_prop:
            print("Focuser does not support absolute position.")
            return False
            
        routine_timeout = time.time() + af_cfg.get('max_duration_s', 180)
        
        pos_widget = abs_pos_prop.findWidgetByName("FOCUS_ABSOLUTE_POSITION")
        current_pos = pos_widget.value
        focuser_min, focuser_max = pos_widget.min, pos_widget.max
        print(f"  Focuser limits: [{focuser_min:.0f} - {focuser_max:.0f}]")
        
        if alt_ft and alt_ft > 0:
            step_size = max(10, int(af_cfg['step_base'] * (10000.0 / alt_ft)))
        else:
            step_size = af_cfg['step_base']
        
        raw_positions = [current_pos + i * step_size for i in range(-af_cfg['scan_range'], af_cfg['scan_range'] + 1)]
        positions = [p for p in raw_positions if focuser_min <= p <= focuser_max]
        if not positions:
            print("Focus failed: No valid scan positions within hardware limits.")
            return False
            
        sharpness_scores = {}
        for pos in positions:
            if time.time() > routine_timeout:
                print("Autofocus aborted: routine exceeded max duration.")
                break
                
            pos_widget.value = pos
            self.sendNewNumber(abs_pos_prop)
            
            focus_timeout = time.time() + 15
            pos_prop = self.focuser.getNumber("ABS_FOCUS_POSITION")
            while pos_prop and pos_prop.s == PyIndi.IPS_BUSY and time.time() < focus_timeout:
                if self.shutdown_event and self.shutdown_event.is_set():
                    print("Autofocus aborted while slewing focuser.")
                    return False
                time.sleep(0.2)
                pos_prop = self.focuser.getNumber("ABS_FOCUS_POSITION")
            
            snap_path = self.snap_image("autofocus")
            sharpness = measure_sharpness(snap_path)
            sharpness_scores[pos] = sharpness
            print(f"  Position {pos:.0f}: Sharpness {sharpness:.2f}")

        if not sharpness_scores:
            print("Focus failed: No sharpness scores were recorded.")
            return False

        best_pos = max(sharpness_scores, key=sharpness_scores.get)
        best_sharp = sharpness_scores[best_pos]
        
        if best_sharp < af_cfg['sharpness_threshold']:
            print(f"Focus failed: Best sharpness ({best_sharp:.2f}) is below threshold.")
            return False

        pos_widget.value = best_pos
        self.sendNewNumber(abs_pos_prop)
        focus_timeout = time.time() + 15
        pos_prop = self.focuser.getNumber("ABS_FOCUS_POSITION")
        while pos_prop and pos_prop.s == PyIndi.IPS_BUSY and time.time() < focus_timeout:
            if self.shutdown_event and self.shutdown_event.is_set():
                print("Autofocus aborted while returning to best position.")
                return False
            time.sleep(0.2)
            pos_prop = self.focuser.getNumber("ABS_FOCUS_POSITION")
            
        print(f"Focused at {best_pos:.0f} with sharpness {best_sharp:.2f}")
        log_path = os.path.join(LOG_DIR, 'focus_logs.json')
        log_entry = {'alt_ft': alt_ft, 'best_pos': best_pos, 'sharpness': best_sharp, 'timestamp': time.time()}
        append_to_json([log_entry], log_path)
        return True

    def capture_image(self, exposure_s: float, save_path: str) -> str:
        os.makedirs(os.path.dirname(save_path), exist_ok=True)
        
        if CONFIG['development']['dry_run']:
            print(f"[DRY RUN] Simulating capture of: {os.path.basename(save_path)}")
            png_path = os.path.splitext(save_path)[0] + ".png"
            img = np.full((180, 320), 40, np.uint8)
            cv2.putText(img, "DRY RUN", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, 200, 2)
            cv2.putText(img, os.path.basename(save_path), (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.4, 180, 1)
            cv2.imwrite(png_path, img)

            hdu = fits.PrimaryHDU(img.astype(np.uint16))
            fits.HDUList([hdu]).writeto(save_path, overwrite=True)
            
            return save_path

        min_exp = CONFIG['capture'].get('exposure_min_s', 0.001)
        max_exp = CONFIG['capture'].get('exposure_max_s', 10.0)
        
        clamped_exp = max(min_exp, min(max_exp, exposure_s))
        if abs(clamped_exp - exposure_s) > 1e-9:
            print(f"  - Warning: Exposure {exposure_s:.3f}s clamped to {clamped_exp:.3f}s (hardware/config limits).")
        exposure_s = clamped_exp
        
        exp_prop = self.camera.getNumber("CCD_EXPOSURE")
        if not exp_prop: raise IOError("CCD_EXPOSURE property not found.")
        
        self._drain_blobs(self._blob_name)
        
        exp_widget = exp_prop.findWidgetByName("CCD_EXPOSURE_VALUE")
        if not exp_widget: raise IOError("CCD_EXPOSURE_VALUE widget not found.")
        exp_widget.value = exposure_s
        self.sendNewNumber(exp_prop)
        
        prop = self.camera.getNumber("CCD_EXPOSURE")
        while prop and prop.s == PyIndi.IPS_BUSY:
            if self.shutdown_event and self.shutdown_event.is_set():
                raise IOError("Capture aborted by shutdown signal.")
            time.sleep(0.1)
            prop = self.camera.getNumber("CCD_EXPOSURE")
            
        timeout = time.time() + max(12, 6 + int(exposure_s * 3.0))
        while time.time() < timeout:
            if self.shutdown_event and self.shutdown_event.is_set():
                raise IOError("Capture aborted by shutdown signal.")
            
            blob_prop = self.camera.getBLOB(self._blob_name)
            if blob_prop is None:
                new_blob_name = self._detect_ccd_blob_name()
                if new_blob_name != self._blob_name:
                    self._blob_name = new_blob_name
                    blob_prop = self.camera.getBLOB(self._blob_name)
            
            if blob_prop and len(blob_prop) > 0 and blob_prop[0].bloblen > 0:
                with open(save_path, 'wb') as f:
                    f.write(blob_prop[0].getblobdata())
                
                try:
                    with fits.open(save_path, mode="update") as hdul:
                        hdr = hdul[0].header
                        hdr['EXPTIME'] = (float(exposure_s), 'Exposure time (s)')
                        hdr['DATE-OBS'] = time.strftime('%Y-%m-%dT%H:%M:%S', time.gmtime())
                        b = self.camera.getNumber("CCD_BINNING")
                        if b:
                            xw, yw = b.findWidgetByName("HOR_BIN"), b.findWidgetByName("VER_BIN")
                            if xw and yw:
                                hdr['XBINNING'] = int(xw.value)
                                hdr['YBINNING'] = int(yw.value)
                        g = self.camera.getNumber("CCD_GAIN")
                        if g:
                            gw = g.findWidgetByName("GAIN")
                            if gw: hdr['GAIN'] = float(gw.value)
                        off = self.camera.getNumber("CCD_OFFSET")
                        if off:
                            ow = off.findWidgetByName("OFFSET")
                            if ow: hdr['OFFSET'] = float(ow.value)
                        t = self.camera.getNumber("CCD_TEMPERATURE")
                        if t:
                            tw = t.findWidgetByName("CCD_TEMPERATURE_VALUE")
                            if tw: hdr['CCD-TEMP'] = float(tw.value)
                        hdul.flush()
                except Exception as e:
                    print(f"Warning: Could not annotate FITS header for {save_path}: {e}")
                
                try:
                    save_png_preview(save_path)
                except Exception as e:
                    print(f"Warning: Could not generate PNG preview for {save_path}: {e}")
                
                return save_path
            time.sleep(0.1)
        
        raise IOError("Image BLOB did not arrive from camera in time.")

    def guide_pulse(self, direction: str, duration_ms: int):
        duration_ms = max(0, int(duration_ms))
        if direction not in ('N','S','E','W'):
            print(f"Warning: Invalid guide direction '{direction}'")
            return

        if CONFIG['development']['dry_run']:
            print(f"[DRY RUN] Sending {duration_ms}ms guide pulse: {direction}")
            time.sleep(duration_ms / 1000.0)
            return

        timed_prop_name, timed_widget_name = "", ""
        if direction in ['N', 'S']:
            timed_prop_name = "TELESCOPE_TIMED_GUIDE_NS"
            timed_widget_name = "TIMED_GUIDE_N" if direction == 'N' else "TIMED_GUIDE_S"
        elif direction in ['W', 'E']:
            timed_prop_name = "TELESCOPE_TIMED_GUIDE_WE"
            timed_widget_name = "TIMED_GUIDE_W" if direction == 'W' else "TIMED_GUIDE_E"

        timed_prop = self.mount.getNumber(timed_prop_name)
        if timed_prop:
            widget = timed_prop.findWidgetByName(timed_widget_name)
            if widget:
                widget.value = duration_ms
                self.sendNewNumber(timed_prop)
                return

        prop_name, widget_name = "", ""
        if direction in ['N', 'S']:
            prop_name = "TELESCOPE_MOTION_NS"
            widget_name = "MOTION_NORTH" if direction == 'N' else "MOTION_SOUTH"
        elif direction in ['W', 'E']:
            prop_name = "TELESCOPE_MOTION_WE"
            widget_name = "MOTION_WEST" if direction == 'W' else "MOTION_EAST"
        else:
            return

        prop = self.mount.getSwitch(prop_name)
        if not prop:
            print(f"Warning: Guide property for direction {direction} not found.")
            return
        
        widget = prop.findWidgetByName(widget_name)
        if not widget:
            print(f"Warning: Guide widget '{widget_name}' not found.")
            return
        
        widget.s = PyIndi.ISS_ON
        self.sendNewSwitch(prop)
        time.sleep(duration_ms / 1000.0)
        widget.s = PyIndi.ISS_OFF
        self.sendNewSwitch(prop)

    def park_mount(self):
        if CONFIG['development']['dry_run']:
            print("[DRY RUN] Parking mount.")
            self.simulated_az_el = (180.0, 0.0)
            return True
        
        park_prop = self.mount.getSwitch("TELESCOPE_PARK")
        if not park_prop:
            print("Warning: Mount does not support PARK command.")
            return False
        
        park_widget = park_prop.findWidgetByName("PARK")
        if not park_widget: park_widget = park_prop[0]
        
        park_widget.s = PyIndi.ISS_ON
        self.sendNewSwitch(park_prop)
        
        print("Parking mount...")
        park_timeout = time.time() + 120
        park_state = self.mount.getSwitch("TELESCOPE_PARK")
        while park_state and park_state.s == PyIndi.IPS_BUSY and time.time() < park_timeout:
            if self.shutdown_event and self.shutdown_event.is_set():
                print("Park aborted by shutdown signal.")
                return False
            time.sleep(1)
            park_state = self.mount.getSwitch("TELESCOPE_PARK")
        
        final_prop = self.mount.getSwitch("TELESCOPE_PARK")
        if final_prop and final_prop.s == PyIndi.IPS_OK:
            print("Mount parked successfully.")
            return True
        else:
            print("Warning: Mount park command timed out or failed.")
            return False

    def snap_image(self, label: str) -> str:
        images_dir = os.path.join(LOG_DIR, 'images')
        os.makedirs(images_dir, exist_ok=True)
        path = os.path.join(images_dir, f"snap_{label}_{time.time_ns()}.fits")
        
        if label.startswith("autofocus"):
            exp = CONFIG['capture'].get('autofocus', {}).get(
                'exposure_s',
                CONFIG['capture']['guiding'].get('guide_exposure_s', CONFIG['capture']['snap_exposure_s'])
            )
        else:
            exp = CONFIG['capture']['guiding'].get('guide_exposure_s', CONFIG['capture']['snap_exposure_s'])
        return self.capture_image(exp, path)

    def capture_sequence(self, icao: str, exposure_s: float, num_images: Optional[int] = None) -> List[str]:
        """
        Captures a burst of images and schedules them for background stacking.
        Returns the list of FITS paths captured (even if stacking fails later).
        """
        if num_images is None:
            num_images = CONFIG['capture'].get('num_sequence_images', 5)
        
        print(f"  Starting capture sequence of {num_images} images with exposure: {exposure_s:.3f}s")
        
        paths = []
        images_dir = os.path.join(LOG_DIR, 'images')
        for i in range(num_images):
            if self.shutdown_event and self.shutdown_event.is_set():
                print("  Capture sequence interrupted by shutdown signal.")
                break
            
            path = os.path.join(images_dir, f"capture_{icao}_{time.time_ns()}_{i+1}.fits")
            try:
                captured_path = self.capture_image(exposure_s, path)
                if captured_path:
                    paths.append(captured_path)
            except Exception as e:
                print(f"  Failed to capture image {i+1}/{num_images}: {e}")

        # Schedule stacking + preview publish so the dashboard preview appears
        if paths:
            try:
                cam_settings = {
                    "gain":   CONFIG['camera_specs'].get('gain'),
                    "offset": CONFIG['camera_specs'].get('offset'),
                    "binning": CONFIG['camera_specs'].get('binning', {"x": 1, "y": 1}),
                }
                sequence_id = f"{icao}_{int(time.time())}"
                schedule_stack_and_publish(sequence_id, paths, cam_settings)
                print(f"  Scheduled stacking for burst {sequence_id} ({len(paths)} frames)")
            except Exception as e:
                print(f"Warning: could not schedule stacking: {e}")
        
        return paths

    def disconnect(self):
        if CONFIG['development']['dry_run']:
            return
        self.disconnectServer()
