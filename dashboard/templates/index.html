<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>ADS-B Tracker Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        body { font-family: sans-serif; margin: 0; padding: 20px; background-color: #1e1e1e; color: #d4d4d4; }
        .container { max-width: 1600px; margin: auto; }
        h1, h2 { color: #569cd6; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .grid { display: grid; gap: 1rem; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }
        .panel { background-color: #252526; padding: 15px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        article { padding: 15px; border-radius: 4px; background-color: #252526; }
        
        .imgbox { background:#111; padding:0.5rem; border-radius:8px; min-height: 180px; text-align: center; }
        .imgbox img { width:100%; height:auto; display:block; border-radius:4px; max-height: 250px; object-fit: contain; margin: auto; }
        
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 0.9em; }
        dt { font-weight: bold; color: #aaa; float: left; width: 140px; clear: left; }
        dd { margin-left: 150px; padding-bottom: 0.2em;}
        dl { overflow: hidden; }
        
        /* Status Classes */
        .status-idle { color: #8f8; }
        .status-tracking, .status-slewing, .status-focusing, .status-acquiring { color: #8df; }
        .status-error { color: #f44747; }
        .tracking-row { background-color: #334; font-weight: bold; }
        .connection-warning { color: #f44747; background-color: #3f1e1e; padding: 5px; border-radius: 3px; display: none; margin-bottom: 1rem; } 

        /* Commands */
        .controls { display: flex; gap: 0.5rem; margin-top: 1rem; flex-wrap: wrap; }
        .controls button { padding: 0.35em 0.9em; margin: 0; border-radius: 4px; border: 1px solid transparent; font-weight: 600; }
        button.danger { background-color: #a42; border-color: #831; color: white; }
        button.auto-btn { color: #fff; }
        button.auto-on { background-color: #2d8a34; border-color: #206423; }
        button.auto-off { background-color: #a42; border-color: #831; }
        button.busy { background-color: #569cd6 !important; border-color: #569cd6 !important; color: #0f0f0f; }
        button:disabled:not(.busy) { background-color: #333; border-color: #333; cursor: not-allowed; }
        
        /* Stack Layouts */
        .stack-grid { display:grid; gap:1rem; grid-template-columns: repeat(auto-fit, minmax(260px,1fr)); }
        .stack-links a { margin-right: .75rem; color: #569cd6; }
        .pill { display:inline-block; padding:.15rem .5rem; border-radius:999px; background:#333; color:#ddd; font-size:.8em; }
        .sep { opacity:.5; margin:0 .25rem; }
        
        /* Lazy Loading (Performance) */
        .lazy-gallery-image { width: 100%; height: 100%; object-fit: contain; display: block; opacity: 0.2; transition: opacity 0.5s; }
        .lazy-gallery-image:not([data-src]) { opacity: 0; } 
        #stack-gallery { display: flex; flex-wrap: wrap; gap: 15px; }

        /* Table Track Form */
        .table-track-form { margin: 0; display: inline-block; }
    </style>
</head>
<body>
<header><h1>ADS-B Tracker Dashboard</h1></header>

<main class="container">
<p id="connection-status-banner" class="connection-warning">CONNECTION LOST. Attempting to reconnect...</p>

<section class="grid">
  <article>
    <h3>System Status</h3>
    <dl class="mono">
      <dt>Mode</dt><dd id="statusText">Initializing...</dd>
      <dt>Target Coords</dt><dd id="targetCoords">—</dd>
      <dt>Mount Coords</dt><dd id="mountCoords">—</dd>
      <dt>Observer</dt><dd id="observerLocation">—</dd>
      <dt>Last Update</dt><dd id="updatedAt">—</dd>
    </dl>
    <div class="controls">
        <form action="/command/abort" method="post" data-command="abort"><button type="submit" id="abortButton" class="danger" disabled>Abort Track</button></form>
        <form action="/command/auto" method="post" data-command="auto"><button type="submit" id="autoButton" class="auto-btn auto-off">Auto Track</button></form>
        <form action="/command/park" method="post" data-command="park"><button type="submit">Park Mount</button></form>
    </div>
  </article>

  <article>
    <h3>Scheduler & Manual Control</h3>
    <dl class="mono">
      <dt>Monitor Mode</dt><dd id="monitorModeText">Off</dd>
      <dt>Manual Target</dt><dd id="manualTargetStatus">None</dd>
      <dt>Scheduler</dt><dd id="schedulerStatus">Idle</dd>
    </dl>
  </article>

  <article>
    <h3>Target Details</h3>
    <dl class="mono">
      <dt>ICAO</dt><dd id="targetIcao">—</dd>
      <dt>Flight</dt><dd id="targetFlight">—</dd>
      <dt>Altitude</dt><dd id="targetAlt">—</dd>
      <dt>Speed</dt><dd id="targetSpeed">—</dd>
      <dt>Track</dt><dd id="targetTrack">—</dd>
    </dl>
    <div class="mono muted" style="margin-top: 0.5rem;">
        Frames: <span id="sequenceCount">—</span> / Exp: <span id="sequenceExp">—</span>s
    </div>
  </article>

  <article>
    <h3>Camera & Hardware Vitals</h3>
    <dl class="mono">
        <dt>Cooler Setpoint</dt><dd id="camSetpoint">—</dd>
        <dt>Camera Temp</dt><dd id="camTemp">—</dd>
        <dt>Cooler Power</dt><dd id="coolerPower">—</dd>
        <dt>Live Binning</dt><dd id="camBinning">—</dd>
        <dt>Live Gain</dt><dd id="camGain">—</dd>
        <dt>Live Offset</dt><dd id="camOffset">—</dd>
        <dt>Focuser Pos</dt><dd id="focuserPos">—</dd>
        <dt>Focuser Temp</dt><dd id="focuserTemp">—</dd>
        <dt>Pier Side</dt><dd id="pierSide">—</dd>
    </dl>
  </article>

  <article>
    <h3>Latest Guide Image</h3>
    <div class="imgbox">
        <img id="guideImg" alt="Guide preview" style="display:none;"/>
        <span id="guide-placeholder">Waiting for image...</span>
    </div>
    <div id="guideInfo" class="mono muted">—</div>
    <div class="mono">Offset: <span id="offsetXY">—</span></div>
    
  </article>

</section>

<section>
  <h2>Latest Stacks <span id="stackBadge" class="pill" style="display:none;"></span></h2>
  <div id="stackMeta" class="mono muted">No stacked sequences yet.</div>
  <div class="stack-grid">
    <article class="stack-card">
      <h4>Mean</h4>
      <div class="imgbox"><img id="stackMeanImg" alt="Mean stack" style="display:none;"></div>
      <div class="stack-links mono muted">
        <a id="meanPngLink" href="#" target="_blank" style="display:none;">PNG</a>
        <span class="sep">·</span>
        <a id="meanFitsLink" href="#" target="_blank" style="display:none;">FITS</a>
      </div>
    </article>
    <article class="stack-card">
      <h4>Robust</h4>
      <div class="imgbox"><img id="stackRobustImg" alt="Robust stack" style="display:none;"></div>
      <div class="stack-links mono muted">
        <a id="robustPngLink" href="#" target="_blank" style="display:none;">PNG</a>
        <span class="sep">·</span>
        <a id="robustFitsLink" href="#" target="_blank" style="display:none;">FITS</a>
      </div>
    </article>
    <article class="stack-card">
      <h4>Anomaly</h4>
      <div class="imgbox"><img id="stackAnomImg" alt="Anomaly map" style="display:none;"></div>
      <div class="stack-links mono muted">
        <a id="anomPngLink" href="#" target="_blank" style="display:none;">PNG</a>
        <span class="sep">·</span>
        <a id="anomFitsLink" href="#" target="_blank" style="display:none;">FITS</a>
      </div>
    </article>
  </div>
</section>

<section>
  <h2>Live Airspace (<span id="allAircraftCount">0</span>)</h2>
  <div style="max-height: 400px; overflow-y: auto;">
    <table>
      <thead>
        <tr>
          <th>ICAO</th>
          <th>Flight</th>
          <th>Altitude (ft)</th>
          <th>Speed (kts)</th>
          <th>Track (°)</th>
          <th>Distance (nm)</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody id="allAircraftTableBody"></tbody>
    </table>
  </div>
</section>

<section>
    <h3>Manual Target Control</h3>
    <form class="controls" action="/command/track" method="post" data-command="track">
        <input type="text" name="icao" id="icao-input" maxlength="6" placeholder="ICAO (e.g., A8C3B1)" required>
        <button type="submit">TRACK ICAO</button>
    </form>
</section>

</main>

<script>
const q = sel => document.querySelector(sel);
const WS_URL = 'ws://' + window.location.host + '/ws/status';
const LATEST_STACK_API_URL = '/api/latest_stack';
const RECONNECT_INTERVAL_MS = 3000;

let websocket;
let reconnectTimeout;
let commandInFlight = false; 

// Global state for link persistence (ensures images don't disappear)
let lastStackSeqId = null;
let lastLinkUrls   = {
  mean:   { png:null, fits:null },
  robust: { png:null, fits:null },
  anomaly:{ png:null, fits:null }
};


/* === helpers === */
function has(v) { return v !== undefined && v !== null; }
function fmt(val, dec = 1) {
  if (!has(val)) return '—';
  const num = Number(val);
  if (Number.isNaN(num) || !Number.isFinite(num)) return '—';
  return num.toFixed(dec);
}

function createButtonForm(icao) {
  const form = document.createElement('form');
  form.action = '/command/track';
  form.method = 'post';
  form.style.margin = '0';
  form.className = 'table-track-form'; // Add class for event delegation

  const input = document.createElement('input');
  input.type = 'hidden';
  input.name = 'icao';
  input.value = icao;
  form.appendChild(input);

  const btn = document.createElement('button');
  btn.type = 'submit';
  btn.textContent = 'Track';
  btn.disabled = commandInFlight;
  form.appendChild(btn);

  return form;
}


/**
 * Apply latest status payload to the dashboard, updating UI, counts, and link state.
 * Expects the same schema delivered by /ws/status (server push).
 */
function updateDashboard(s) {
    const monitorMode = !!s.monitor_mode;
    const isTracking = s.mode && !['idle', 'initializing', 'error', 'monitor'].includes(s.mode);
    const abortBtn = q('#abortButton');
    abortBtn.disabled = !(isTracking || has(s.manual_target));
    const idleBtn = q('#idleButton');
    const autoBtn = q('#autoButton');
    if (idleBtn) idleBtn.disabled = monitorMode || commandInFlight;
    if (autoBtn) autoBtn.disabled = (!monitorMode && !s.manual_target) || commandInFlight;

    // Status Panel
    const statusEl = q('#statusText');
    let modeText = s.mode || 'unknown';
    const mode = (s.mode || 'unknown').replace(/\s+/g, '-');
    statusEl.className = `mono status-${mode}`;
    if (s.mode === 'slewing' && s.target_az_el) {
        modeText = `Slewing to ${fmt(s.target_az_el[0])}° Az`;
    } else if (s.mode === 'focusing' && s.autofocus_alt_ft) {
        modeText = `Focusing (Alt: ${fmt(s.autofocus_alt_ft, 0)} ft)`;
    } else if (s.mode === 'tracking' && s.iteration) {
        modeText = `Tracking (Frame: ${s.iteration})`;
    } else if (s.mode === 'acquiring') {
        modeText = 'Acquiring Target...';
    } else if (s.mode === 'monitor') {
        modeText = 'Monitor Mode (Idle)';
    } else if (s.mode === 'idle') {
        modeText = 'Idle - Monitoring';
    }
    statusEl.textContent = modeText;

    q('#monitorModeText').textContent = monitorMode ? 'On' : 'Off';
    const monitorEl = q('#monitorModeText');
    monitorEl.className = monitorMode ? 'mono status-alert' : 'mono muted';

    const manualInfo = s.manual_target || null;
    if (manualInfo) {
        let manualText = manualInfo.icao ? manualInfo.icao.toUpperCase() : 'Pending';
        const viability = manualInfo.viability || {};
        if (viability.viable === true) {
            manualText += ' · viable';
        } else if (Array.isArray(viability.reasons) && viability.reasons.length) {
            manualText += ' · ' + viability.reasons.join('; ');
        } else {
            manualText += ' · evaluating';
        }
        q('#manualTargetStatus').textContent = manualText;
    } else if (s.manual_override_active) {
        q('#manualTargetStatus').textContent = `Tracking ${s.manual_override_active.toUpperCase()}`;
    } else {
        q('#manualTargetStatus').textContent = 'None';
    }

    let schedulerText = 'Auto';
    if (monitorMode) schedulerText = 'Monitoring';
    else if (manualInfo && manualInfo.viability && Array.isArray(manualInfo.viability.reasons) && manualInfo.viability.reasons.length) {
        schedulerText = manualInfo.viability.reasons.join('; ');
    } else if (manualInfo) {
        schedulerText = `Waiting for ${manualInfo.icao?.toUpperCase() || 'target'}`;
    } else if (s.manual_override_active) {
        schedulerText = `Manual track: ${s.manual_override_active.toUpperCase()}`;
    }
    q('#schedulerStatus').textContent = schedulerText;
    
    q('#targetCoords').textContent = has(s.target_az_el) ? `az ${fmt(s.target_az_el[0])}, el ${fmt(s.target_az_el[1])}` : '—';
    q('#mountCoords').textContent = has(s.mount_az_el) ? `az ${fmt(s.mount_az_el[0])}, el ${fmt(s.mount_az_el[1])}` : '—';
    q('#observerLocation').textContent = has(s.observer_loc) ? `Lat ${fmt(s.observer_loc.lat, 2)}, Lon ${fmt(s.observer_loc.lon, 2)}` : '—';
    q('#updatedAt').textContent = has(s.updated_at) ? new Date(s.updated_at*1000).toLocaleTimeString() : '—';

    // Target Details Panel
    const details = s.target_details || {};
    q('#targetIcao').textContent = s.icao || '—';
    q('#targetFlight').textContent = details.flight ? details.flight.trim() : '—';
    q('#targetAlt').textContent = has(details.alt) ? `${fmt(details.alt, 0)} ft` : '—';
    q('#targetSpeed').textContent = has(details.gs) ? `${fmt(details.gs, 1)} kts` : '—';
    q('#targetTrack').textContent = has(details.track) ? `${fmt(details.track, 1)}°` : '—';
    q('#sequenceCount').textContent = s.sequence_count || '—';
    q('#sequenceExp').textContent = has(s.sequence_exposure_s) ? fmt(s.sequence_exposure_s, 3) : '—';

    // Camera & Hardware Vitals Panel
    const settings = s.camera_settings || {};
    q('#camSetpoint').textContent = settings.cooling ? `${fmt(settings.cooling.setpoint_c, 1)} °C` : '—';
    q('#camTemp').textContent = has(s.camera_temp) ? `${fmt(s.camera_temp, 1)} °C` : '—';
    q('#coolerPower').textContent = has(s.camera_cooler_power) ? `${fmt(s.camera_cooler_power, 1)} %` : '—';
    q('#camBinning').textContent = s.camera_binning ? `${fmt(s.camera_binning.x, 0)}x${fmt(s.camera_binning.y, 0)}` : '—';
    q('#camGain').textContent = has(s.camera_gain) ? fmt(s.camera_gain, 0) : '—';
    q('#camOffset').textContent = has(s.camera_offset) ? fmt(s.camera_offset, 0) : '—';
    q('#focuserPos').textContent = has(s.focuser_pos) ? fmt(s.focuser_pos, 0) : '—';
    q('#focuserTemp').textContent = has(s.focuser_temp) ? `${fmt(s.focuser_temp, 1)} °C` : '—';
    q('#pierSide').textContent = s.mount_pier_side || '—';
    
    // Guide Image and Info
    const guideEl = q('#guideImg');
    const guidePlaceholder = q('#guide-placeholder');
    const mtime = s.last_guide_mtime; 
    const guideUrl = s.last_guide_png;

    if (guideUrl && mtime) {
        const cacheBusterUrl = guideUrl + '?t=' + mtime; 
        if (guideEl.src !== cacheBusterUrl) {
            guideEl.onload = () => { guideEl.style.display = 'block'; guidePlaceholder.style.display = 'none'; };
            guideEl.onerror = () => { guideEl.style.display = 'none'; guidePlaceholder.style.display = 'block'; };
            guideEl.src = cacheBusterUrl;
        }
    } else {
        guideEl.style.display = 'none';
        guidePlaceholder.style.display = 'block';
    }
    
    q('#guideInfo').textContent = s.last_guide_file || '—';
    q('#offsetXY').textContent = has(s.guide_offset_px) ? `dx=${fmt(s.guide_offset_px.dx)}, dy=${fmt(s.guide_offset_px.dy)} px` : '—';

    // Update Live Airspace Table
    const allAircraft = s.all_aircraft || [];
    q('#allAircraftCount').textContent = allAircraft.length;
    const tbody = q('#allAircraftTableBody');
    tbody.innerHTML = '';
    allAircraft.sort((a, b) => (a.dist_nm ?? Infinity) - (b.dist_nm ?? Infinity));
    
    allAircraft.forEach(ac => {
        const tr = document.createElement('tr');
        if (ac.icao === s.icao) tr.classList.add('tracking-row');
        
        const cells = [
          { text: ac.icao, classes: ['mono'] },
          { text: ac.flight || 'N/A', classes: ['mono'] },
          { text: fmt(ac.alt, 0) },
          { text: fmt(ac.gs, 1) },
          { text: fmt(ac.track, 1) },
          { text: fmt(ac.dist_nm, 1) },
        ];

        cells.forEach(c => {
            const td = document.createElement('td');
            if (c.classes) td.classList.add(...c.classes);
            td.textContent = c.text;
            tr.appendChild(td);
        });

        const actionTd = document.createElement('td');
        const form = createButtonForm(ac.icao);
        form.querySelector('button').disabled = commandInFlight; // Disable if command is running
        actionTd.appendChild(form);
        tr.appendChild(actionTd);
        
        tbody.appendChild(tr);
    });
}


/**
 * Render the latest stack payload, keeping existing images/links when API omits them.
 * Accepts payload from /api/latest_stack.
 */
function renderLatestStackPayload(p) {
  if (!p || !p.products) return;

  const when = p.timestamp ? new Date(p.timestamp*1000).toLocaleString() : '—';
  q('#stackMeta').textContent = `ICAO ${p.icao} · Seq ${p.sequence_id} · ${when}`;
  const badge = q('#stackBadge');
  badge.textContent = p.icao || '';
  badge.style.display = p.icao ? 'inline-block' : 'none';

  const mean    = p.products.mean    || {};
  const robust  = p.products.robust  || {};
  const anom    = p.products.anomaly || {};
  
  // Find the URL currently being displayed on the screen. This is the fallback.
  // We check against 'none' because that's what the image will be if it fails loading/is hidden.
  const currentMeanUrl = q('#stackMeanImg').src.split('?')[0];
  const currentRobustUrl = q('#stackRobustImg').src.split('?')[0];
  const currentAnomUrl = q('#stackAnomImg').src.split('?')[0];

  // CORE FIX: Use new URL (if present) OR the currently displayed URL as the final source.
  const finalMeanUrl = mean.png || (currentMeanUrl.endsWith('none') ? null : currentMeanUrl);
  const finalRobustUrl = robust.png || (currentRobustUrl.endsWith('none') ? null : currentRobustUrl);
  const finalAnomUrl = anom.png || (currentAnomUrl.endsWith('none') ? null : currentAnomUrl);

  // 1. Update Images (only called if final URL is non-null)
  if (finalMeanUrl)   _setImgOnce(q('#stackMeanImg'), finalMeanUrl);
  if (finalRobustUrl) _setImgOnce(q('#stackRobustImg'), finalRobustUrl);
  if (finalAnomUrl)   _setImgOnce(q('#stackAnomImg'), finalAnomUrl);

  // 2. Update Links (uses lastLinkUrls cache)
  _setLinkStable(q('#meanPngLink'),   mean.png,   'mean',   'png');
  _setLinkStable(q('#meanFitsLink'),  mean.fits,  'mean',   'fits');
  _setLinkStable(q('#robustPngLink'), robust.png, 'robust', 'png');
  _setLinkStable(q('#robustFitsLink'),robust.fits,'robust', 'fits');
  _setLinkStable(q('#anomPngLink'),   anom.png,   'anomaly','png');
  _setLinkStable(q('#anomFitsLink'),  anom.fits,  'anomaly','fits');

  lastStackSeqId = p.sequence_id || lastStackSeqId;
}

/**
 * Updates an image element only if the new URL is different OR if the image needs restoring.
 * @param {HTMLElement} el The <img> element.
 * @param {string | null} url The new image URL.
 */
function _setImgOnce(el, url) {
  if (!el || !url) return;
  
  // Check against the current source URL base
  const currentUrlBase = el.src.split('?')[0]; 

  // If the new URL is identical to the currently displayed URL base, do nothing.
  if (currentUrlBase === url) { 
      return; 
  }

  // Load the new image with cache busting
  el.onload = () => { el.style.display = 'block'; };
  el.onerror = () => { el.style.display = 'none'; }; // Hide only if load fails
  el.src = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now();
}


/**
 * Updates link persistence (avoids link flicker/disappearance if API returns null)
 */
function _setLinkStable(el, newUrl, variant, kind) {
  if (!el) return;
  const prev = lastLinkUrls[variant][kind];
  if (newUrl) {
    el.href = newUrl;
    el.style.display = 'inline';
    lastLinkUrls[variant][kind] = newUrl; // Cache the new URL
  } else if (prev) {
    el.href = prev;
    el.style.display = 'inline'; // Keep the old link active
  } else {
    el.style.display = 'none';
    el.removeAttribute('href');
  }
}


/** Fetch the latest stack on demand (used after WebSocket updates). */
function refreshLatestStack(){
  fetch('/api/latest_stack', {cache:'no-store'})
    .then(r => { if (r.status === 404) return null; return r.json(); })
    .then(data => renderLatestStackPayload(data))
    .catch(() => {/* ignore transient errors; keep current images/links */});
}

// ====================================================================
// WebSocket and Command Logic
// ====================================================================

function resetCommandButtons() {
    commandInFlight = false;
    document.querySelectorAll('.controls button, .table-track-form button').forEach(btn => {
        btn.disabled = false;
        btn.classList.remove('busy');
        const command = btn.getAttribute('data-command') || 'track'; 
        
        if (command === 'track' && btn.getAttribute('type') === 'submit') btn.textContent = 'Track';
        else if (command === 'abort') btn.textContent = 'Abort Track';
        else if (command === 'park') btn.textContent = 'Park Mount';
        else if (command === 'auto') btn.textContent = 'Auto Track';
    });
}

function handleCommandForms() {
    document.querySelectorAll('form').forEach(form => {
        form.addEventListener('submit', function(e) {
            
            // Check for ongoing command regardless of form class
            if (commandInFlight) {
                e.preventDefault();
                return;
            }
            
            const btn = this.querySelector('button');
            const command = btn.getAttribute('data-command') || (form.action.includes('track') ? 'track' : null);
            const icaoInput = this.querySelector('input[name="icao"]');
            
            // Validation
            if (command === 'track') {
                const icao = icaoInput.value.trim().toUpperCase();
                if (!/^[A-F0-9]{6}$/.test(icao)) {
                    e.preventDefault();
                    alert('Invalid ICAO format. Must be 6 hex characters (A-F, 0-9).');
                    return;
                }
                icaoInput.value = icao; 
            }
            
            // Optimistic Update
            commandInFlight = true;
            document.querySelectorAll('button').forEach(b => b.disabled = true);
            if (command) {
                btn.textContent = 'SENT...';
                btn.classList.add('busy');
            }
        });
    });
}

/** Establish a resilient WebSocket connection with automatic reconnect. */
function connectWebSocket() {
    clearTimeout(reconnectTimeout);
    
    const ws = new WebSocket(WS_URL);

    ws.onopen = () => {
        q('#connection-status-banner').style.display = 'none';
    };

    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        updateDashboard(data);
        refreshLatestStack();

        // Check if command state has been resolved
        if (commandInFlight && (data.mode !== 'slewing' && data.mode !== 'acquiring' && data.mode !== 'focusing')) {
            resetCommandButtons();
        }
    };

    ws.onclose = (event) => {
        q('#connection-status-banner').style.display = 'block';
        reconnectTimeout = setTimeout(connectWebSocket, RECONNECT_INTERVAL_MS);
    };

    ws.onerror = (error) => {
        ws.close();
    };
}

document.addEventListener('DOMContentLoaded', () => {
    setInterval(() => {
        q('#updatedAt').textContent = new Date().toLocaleTimeString();
    }, 1000);
    
    connectWebSocket();
    handleCommandForms();
});
</script>
</body>
</html>
